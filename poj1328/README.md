# algorithm

说一下poj1328的思路和遇到的问题
首先把问题压缩到一维空间上，即以各个点为圆心，以d为半径画圆，若圆与x轴无交点则说明无解；若有交点则会在x轴上留下两个或一个点。那么可以将这两个点想想成一个区间，如果存在共同的雷达点，那么两个区间必须相交，否则就必须建两个雷达点。

# 思路：
求出每个岛屿点与坐标轴x的交点区间，然后将这些区间按照左端点进行从小到大排序，然后对相邻两个区间进行相交的比较：比较右端点。
若当前区间的左端点 < 上一个区间右端点,说明没有交点，则雷达点加1；
此时还有一种情况就是当前区间是上一个区间的子集，也就是
若当前区间的右端点 < 上一个区间的右端点，那么将当前区间右端点 作为 下一次比较的 区间右端点。

#遇到的问题
也许是好久没用c写程序，出现了好多低级错误
条件与 && 写成了 按位与 &
qsort在g++和gcc中不能使用，只好使用sort，可是sort在c++中std::sort，所以只好加入using namespace std；

